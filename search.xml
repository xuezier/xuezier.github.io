<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[egg.js 打造高可用服务集群]]></title>
    <url>%2F2019%2F10%2F24%2Fegg-%E6%89%93%E9%80%A0%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%8D%E5%8A%A1%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[前言Q4 了，秋高气爽适合养生。每天昏昏欲睡的我，今晚突然血气上涌，又来滥竽充数发表 yy 文了😁。 今日份主题：高可用服务！ 以下服务案例是以 egg.js 为基础搭建。 理解高可用服务高可用也就是大家常说的HA（High Availability），高可用的引入，是通过设计减少系统不能提供服务的时间，而不能保证系谢统可用性是能达到100%的！ 不能保证系统可用性是能达到100%的！ 不能保证系统可用性是能达到100%的！ 不能保证系统可用性是能达到100%的！ 背景目前我们公司的服务部署主要分两种，一种是传统的多 ecs 服务器分布式集群，一种是 k8s 托管集群服务。 题主负责的服务大多是以 ecs 部署为主💻，内容展开也是以此为基础。 先看一组图 高可用的准则基本上保证服务的高可用遵循两个原则 集群化 故障自动化处理 集群化主要还是分两类 单机进程集群 多机集群 集群化的部署本身也是为了规避单点（单进程、单机）故障导致的服务不可用的问题。当集群中某个服务/进程挂掉的时候，该单点所承载的流量会被其他服务/进程分担。 单机进程集群单机进行多进程集群的部署，当集群中的某一个进程挂掉的时候，应该感知该进程的故障，及时将进程进行清理，流量均摊到其他进程，直到故障进程被重新拉起。 通常我们为了合理利用 cpu 资源，会根据 cpu 核心的数量启动相应数量的进程，但在单核机器上时，cpu 的核心数只有 1，针对单核机器需要做特殊处理。 我们可以通过一个简单的例子将启动命令通过脚本文件进行包装12345678910111213141516171819// scripts/start.jsconst os = require('os');const child_process = require('child_process');const cores = os.cpus().length;// 当核心数只有 1 的时候，启动两个 worker 进程，其他情况根据 cpu 核心数启动 worker 进程const workers = cores === 1 ? 2: cores;const command = 'npm';const argv = ['start', '--', `--workers=$&#123;worker&#125;`];const child = child_process.spawn(command, argv);child.stdout.on('data', (data) =&gt; &#123; console.log(`stdout: $&#123;data&#125;`);&#125;);child.stderr.on('data', (data) =&gt; &#123; console.error(`stderr: $&#123;data&#125;`);&#125;); 整理一下 package.json 的 scripts123456&#123; "scripts": &#123; "start": "eggctl start --daemon --title=egg-server-myProject", "scripts:start": "node scripts/start" &#125;&#125; 这样子当我们通过指令 npm run scripts:start 来启动服务的时候 ，可以先获取当前机器的 cpu 核心数量来合理启动相应数量的 worker 进程。 多机集群多机集群的目的是为了防止单机部署的一些不可控因素导致的服务不可用的情况，比如某些意外导致的宕机😣。。。可以及时的将宕机的流量均摊到集群中的其他机器上去。 多机集群通常通过负载均衡让每个节点都分担请求流量。据我了解到的阿里 slb 服务是改造过的 nginx - Tengine。原理和 nginx 实现的负载均衡类似，只是它本身就是高可用的服务，我们不需要去维护这个负载均衡服务。 资源冗余不要为了省钱而采用够用就好的资源配置💥。当一台 2c4g 的机器能够承载 200qps 的时候，需要对机器的硬件资源做冗余，比如升级成 4c8g。否则当某个节点突然请求量上升，或系统本身服务在做一些处理比如日志轮转的时候，会造成资源竞争，导致一些不可控的问题。 关于资源冗余的点，ecs 部署相对于 k8s 来说，确实是属于资源编排相对浪费的的部署方式。 keepalived在负载均衡(slb)中，通过 健康检查 检测服务器的工作状态，如果该服务器出现故障被检测到，将其剔除服务器群，直至正常工作后，自动检测到并加入到服务器群里面。 预发布通常的测试环境与线上环境存在一些差异，可能会规避掉一些上线部署的风险😨。😖为了能保证代码上线能正常启动服务，应该预留一个与线上几乎一致的内部环境（网络，依赖，配置信息等）- 我们姑且称之为预发机器，先进行代码的预发布流程。当服务在预发机器能正常工作后，才将代码往线上发布。 版本迭代的平滑互联网时代的发展是迅速的，需求每天都在变化。新的需求每天都在产生🔪，服务本身不会保持一成不变。我们每天都有大量的需求更新和 bug😣 fix 上线。 保证代码发布的平滑，是高可用中不可缺少的一环，对于 egg.js 服务集群如何做平滑重启，可以参考我之前发表的文章😁 《Egg.js 多机平滑重启实践》 api 过渡通常随着版本的长期迭代，旧的 api 可能已经不满足业务需求，需要对 api 进行升级，这个时候新旧 api 是不兼容的🤔。 当新旧 api 进行切换的时候，会产生某些业务还依赖旧的 api，如果直接将旧的 api 进行改造，很可能对某些业务带来影响。 出现这种情况，从我们处理的经验上讲，新的 api 已经不兼容旧版本的 api，那么还是会保留旧的 api 接口，另外设计 v2 版本的新 api，保证新 api 在上线的时候，新旧 api 共存，直到业务方改造完毕，才废除旧版本的 api🙋。 服务降级在突发大流量的情况下，可能会导致服务整体质量下滑的情况。这时候可以做服务降级来关闭一些不重要的服务来降低资源消耗。 对于服务降级的方案，我的考虑是这样的 统一的分布式开关，由配置中心（如 apollo）管理； 服务接入开关，并在一些非关键部位/接口上引入开关。接口方面可以通过中间件做开关； 操作配置中心的开关项，可以动态控制开关； 服务被通知开关变更，及时修改内部接口开关； 监控前瞻性的监控预警是对服务高可用的一个保障。多维度的监控警报可以在故障的第一时间将问题抛到相应的负责人手上处理🐛。 监控的方式有很多，基础的监控有依赖阿里的云监控，rds、redis、ecs 等监控。 node 相关服务可以使用 alinode 做一些应用/主机级别的监控。 可选的一些监控体系如 elk 日志监控，sentry，opentracing 慢链路监控等。 总结总之保证服务的高可用，简单的一句话就是不要把鸡蛋都放在一个篮子里，也不要让臭鸡蛋坏在篮子里。 one more thing最后，该来的还是要来😁 如果你也对 eggjs，对 nodejs，对 js 有兴趣，有想探讨的问题，可以联系我的邮箱📮tunan@gaoding.com。 如果你对我们的工作感兴趣，想和我们一起攻克难关的话，也可以直接将简历发到我的邮箱。 我们有专职的 nodejs 研发工程师，有在厦门具有相当影响力的前端团队，相信喜欢 js 喜欢 nodejs 的你会喜欢我们的团队～ 我们是：稿定（厦门）科技有限公司 - 平台技术部]]></content>
      <tags>
        <tag>node.js</tag>
        <tag>javascript</tag>
        <tag>egg.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[how to design a koa middleware]]></title>
    <url>%2F2019%2F10%2F15%2Fhow-to-design-a-koa-middleware%2F</url>
    <content type="text"><![CDATA[前言该中间件设计规范是我们在平时工作中实践总结的经验之谈，欢迎小伙伴吐槽改善。 Middleware中间件在 node.js 的 web 应用中是非常常见的一个功能设计。众多 web 框架（express、koa、nest.js、connect 等）都有中间件的设计支持。虽然不同框架中间件没有统一的设计规范，但在功能和实现上几乎是异曲同工的。 中间件在 web 服务中主要的作用就是访问 request 和 response 对象，完成特定任务后下发到下一个中间件。中间件的设计极大的对请求进行了分片化，可以让很多原本需要在 controller 中处理的问题更方便的做统一的逻辑处理。 我根据中间件的生成主要将其分为两种 工厂化中间件 简单来讲就是有一个工厂函数，根据传入的参数动态生成的中间件，这样的中间件会根据传入的参数不同可能会有不同的处理逻辑 静态中间件 从一开始就确定工作内容的中间件 设计规范middleware 和 controller 都可以访问 request 和 response 对象，也可完成和 controller 一样的事情，那么 middleware 和 controller 有什么区别呢？ 首先 middleware 的设计应该遵守以下几个规范： 去中心化的 避免闭包设计 无论是工厂化中间件还是静态中间件，一旦确定在 runtime 就是不可变更的 去中心化这是和 controller 设计区别最大的地方。 事实上，controller 也可以算是一个中间件，但是 controller 通常是设计为具有业务相关性的方法，我将 controller 在 node 中的设计定位 fake-middleware。 而我们需要真正去设计的 middleware 应该是具有业务无关性的，一个无状态的去中心化的方法。middleware 应该具有更强的通用普适性，这个通用性分为两种，一种是应用相关的，一种是应用无关的。 先说应用相关性的中间件：例如一个短信应用，通常会有各种防刷机制，这种预防机制通常是在中间件中实现的。短信的防刷和短信发送本身是业务无关的，但是短信防刷机制通常只在短信相关应用（用户系统，短信系统等）中需要。这种中间件就是具有应用相关性的。 再说应用无关性的中间件：很常见的一些中间件如 cors、body-parser 等，都是具有非常强的通用性，而且和任何类型应用都没有相关性。 最后，无状态的去中心化怎么理解？举个例子，在 Java 应用中，controller 通常会先对请求的参数做参数检查。在 node 中可以通过中间件来做统一的参数检查。但是不同的接口通常都需要不同的参数，如果每个接口都设计一个 middleware 来做参数检查，那就显得很鸡肋（我干嘛做这种蠢事？）。但实际上我还真见到过😂。 以 egg 为例，我们通过两个例子看一下1234567891011// example-1 - badasync function ParamterValidateMiddleware(ctx, next) &#123; const &#123; body &#125; = ctx.request; ctx.validate(&#123; param1: 'string', param2: 'number' &#125;, body); await next();&#125; 1234567891011// example-2 - goodfunction ParamterValidateMiddlewareFactory(options) &#123; return async function ParamterValidateMiddleware(ctx, next) &#123; const &#123; body &#125; = ctx.request; const &#123; rules &#125; = options; ctx.validate(rules, body); await next(); &#125;&#125; example-1 的设计只能针对单一的接口，如果参数发生变动，就需要修改对应的 middlware 方法。 example-2 将参数校验进行工厂化设计，通过传入的 rules，动态生成对应接口所需的中间件，那么就可以在全局维护统一的参数表。 避免闭包设计无论是前端后端，只要是做 js 的，那么面试的时候应该很经常能遇到一个问题，那就是闭包。对于闭包的知识，可以自行百度，这里就不展开。中间件中避免闭包的设计，主要是闭包是引起内存泄露的一个因素。在中间件中，不规范的闭包设计会造成故障排查的困难（内存泄露没有错误堆栈可以看啊！😣）。 举个例子🌰：1234567async function ClosureInMiddleware(ctx, next) &#123; function setSomethingToReq() &#123; ctx.req[Symbol.for('Somthing')] = Date.now(); &#125; await next();&#125;]]></content>
      <tags>
        <tag>node.js</tag>
        <tag>javascript</tag>
        <tag>koa</tag>
        <tag>middleware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[X-Y PROBLEM]]></title>
    <url>%2F2019%2F05%2F22%2FX-Y-PROBLEM%2F</url>
    <content type="text"><![CDATA[1）有人想解决问题X 2）他觉得Y可能是解决X问题的方法 3）但是他不知道Y应该怎么做 4）于是他去问别人Y应该怎么做？]]></content>
  </entry>
  <entry>
    <title><![CDATA[typescript - decorator(1)]]></title>
    <url>%2F2019%2F03%2F01%2Ftypescript-decorator%2F</url>
    <content type="text"><![CDATA[介绍With the introduction of Classes in TypeScript and ES6, there now exist certain scenarios that require additional features to support annotating or modifying classes and class members. Decorators provide a way to add both annotations and a meta-programming syntax for class declarations and members. 翻译： 随着 typescript 和 es6 中类的引入，现在存在一些场景，需要额外的功能来支持对类和类成员进行修饰或修改。decorator(装饰器) 提供了一种为类声明和成员添加修饰和元编程语法的方法。 装饰器装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。 装饰器使用 @expression 这种形式，expression 求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。 装饰器的作用是为类声明和成员添加修饰和元编程语法。首先要了解，什么样的场景下需要做这样的装饰器。 有一个类 Person:12345class Person &#123; say(sentence) &#123; console.log(sentence); &#125;&#125; Person 有一个实例方法 say，可以说话。但有一个问题， 假如 Person 的实例 mick 喜欢说脏话，比如 cnm 这样的。那么我想让 mick 沉默，或者 cnm 就变成 bi~~~~。 通常的做法是给 say 方法加一些内容:12345678class Person &#123; say(sentence) &#123; sentence = sentence.replace(/cnm/g, 'bi~~~'); console.log(sentence); &#125;&#125;const mick = new Person();mick.say(); 用装饰器实现123456789101112131415161718// workFilter 是一个 decoratorfunction wordFilter(target: any, name: string, descriptor: PropertyDescriptor) &#123; const fun = descriptor.value; descriptor.value = function(sentence) &#123; sentence = sentence.replace(/cnm/g, 'bi~~~'); return fun.call(this, sentence); &#125;&#125;class Person &#123; @wordFilter say(sentence) &#123; console.log(sentence); &#125;&#125;const mick = new Person();mick.say(); 简单理解装饰器就是在原有的代码上包装了一层， 可以想像手枪的枪口装了消音器，水龙头的进水管加装了净水器一样，不改变原有的实现逻辑，增加原来不存在的功能或特性。 装饰器种类装饰器主要分为类装饰器和方法装饰器，分别用来修饰类声明和成员。 类装饰器类装饰器只有一个参数 target 类的构造函数 方法装饰器方法装饰器有三个参数 target any, 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象 name string, 成员的名字 descriptor TypedPropertyDescriptor, 成员的属性描述符 value: any 成员的值 writable: boolean 是否修改 enumerable: boolean 是否可遍历 configurable: boolean 成员描述是否可改变或者成员是否可删除 get 成员的 getter 方法 set 成员的 setter 方法 装饰器工厂装饰器工厂就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。12345678910111213141516171819function wordFilter(word) &#123; const reg = new RegExp(word, 'g'); return function wordFilter(target: any, name: string, descriptor: PropertyDescriptor) &#123; const fun = descriptor.value; descriptor.value = function(sentence) &#123; sentence = sentence.replace(reg, 'bi~~~'); return fun.call(this, sentence); &#125; &#125;&#125;@wordFilter('cnm')class Person &#123; @wordFilter say(sentence) &#123; console.log(sentence); &#125;&#125; 参考 【Typescript - Decorators】]]></content>
      <tags>
        <tag>typescript</tag>
        <tag>javascript</tag>
        <tag>decorator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[exports 和 module.exports 的区别]]></title>
    <url>%2F2018%2F07%2F16%2Fexports-%E5%92%8C-module-exports-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[node.js 编写模块的时候，为了保证模块的可读性，推荐把不同功能的代码都写成独立的模块，减少各模块的耦合。 在 node 中， 每个 js 执行文件都会自动创建 module 对象，同时。module 对象默认带有 exports 属性。初始值是 {}。1module.exports = &#123;&#125;; 在 js 模块里，可以直接调用 module 和 exports 对象。但 exports 是 module.exports 的一个引用。 module.js12345var say = function(name) &#123; console.log('hello ' + name);&#125;exports.say = say; index.js123var module = require('module.js');module.say('god'); // console print: hello god. 在 node 的编译过程中，会把 js 模块进行封装。12345678// require 是对 Node.js 实现查找模块的 Module._load 实例的引用// __finename 和 __dirname 是 Node.js 在查找该模块后找到的模块名称和模块绝对路径(function(exports,require,module,__filename,__dirname)&#123; function say(name)&#123; console.log('hello ' + name); &#125; exports.say = say;&#125;) 要将函数直接导出成模块而不是 exports 的一个方法，需要 module.js123456var say = function(name) &#123; console.log('hello ' + name);&#125;module.exports = say;// wrong example// exports = say; index.js12var say = require('module.js');say('god'); // console print: hello god 综上，在 js 模块创建的时候1exports = module.exports = &#123;&#125;; exports 是 module.exports 的一个引用 module.exports 初始值为一个空对象 {}，所以 exports 初始值也是 {} require 引用模块后，返回的是 module.exports 而不是 exports exports.xxx 相当于在导出对象上挂属性，该属性对调用模块直接可见 exports = 相当于给 exports 对象重新赋值，调用模块不能访问 exports 对象及其属性 如果此模块是一个类，就应该直接赋值 module.exports，这样调用者就是一个类构造器，可以直接 new 实例。 例如1234var obj = &#123; inner : &#123;&#125;&#125;;var inner = obj.inner; inner 就是 obj.inner 的一个引用，改变 inner 的属性会 同时对 obj.inner 的属性进行改变123456789inner.name= 'god';console.log(obj);/*** &#123;* inner: &#123;* name: 'god'* &#125;* &#125;*/ 但是对 inner 重新赋值，并不会对 obj.inner 造成影响123456789inner = &#123;name: 'devil'&#125;;console.log(obj);/*** &#123;* inner: &#123;* name: 'god'* &#125;* &#125;*/]]></content>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grpc typescript 实例]]></title>
    <url>%2F2018%2F06%2F26%2Fgrpc-typescript-%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[前言gRPC 是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计。目前提供 C、Java 和 Go 语言版本，分别是：grpc, grpc-java, grpc-go. 其中 C 版本支持 C, C++, Node.js, Python, Ruby, Objective-C, PHP 和 C# 支持. gRPC 基于 HTTP/2 标准设计，带来诸如双向流、流控、头部压缩、单 TCP 连接上的多复用请求等特。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。 正如其他 RPC 系统，gRPC 基于如下思想：定义一个服务， 指定其可以被远程调用的方法及其参数和返回类型。gRPC 默认使用 protocol buffers 作为接口定义语言，来描述服务接口和有效载荷消息结构。 包装最近转向 typescript 做 node 开发， 基于 express 的 mvc 服务框架涉及到与其他语言服务进程通信，于是就把之前用 javascript 写的 grpc 包装重新用 typescript 写了一遍。 grpc-ts 分为两个包，一个服务端用的，一个客户端用的, 点击可跳转到 GitHub: grpc-server-ts grpc-client-ts 使用这里是配合基于 express 的 typescript-mvc 框架 mvc-ts 使用的。 mvc-ts 定义统一的 proto 文件hello.proto12345678910111213141516171819syntax = "proto3";option java_multiple_files = true;option java_package = "io.grpc.service.test";option objc_class_prefix ="RTG";package hello;service Hello &#123; rpc say(stream Empty) returns (stream Word) &#123;&#125;;&#125;message Empty &#123;&#125;message Word &#123; string word = 1;&#125; 服务端使用定义servicehelloService.ts123456789import &#123; Route, Service &#125; from "grpc-server-ts";@Service('path_to_hello.proto')export class HelloService &#123; @Route public async say() &#123; return 'hello world'; &#125;&#125; 开启服务1234567import &#123; RpcRegistry, Settings &#125; from 'grpc-server-ts';import 'helloService.ts';@Settings(settings)class RPC extends RpcRegistry &#123; &#125;RPC.start(); settings 参数1234567&#123; port: "3333", // listen port host: "localhost", // listen host ca: "runtime/rpc/ca.crt", // ca file path cert: "runtime/rpc/server.crt", // cert file path key: "runtime/rpc/server.key" // key file path&#125; 服务端的 grpc 就启动在 localhost:3333 客户端使用定义client, Hello.ts1234567import &#123; Route, Client &#125; from 'grpc-client-ts';@Client(__dirname + '/protobuf/Hello.proto')export class Hello &#123; @Route public async say(data, result) &#123; &#125;&#125; 创建一个controller，HelloController.ts12345678910111213141516import * as Express from 'express';import &#123; Inject, RestController, Get, Res &#125; from "mvc-ts";import &#123; Hello &#125; from 'Hello.ts';@RestController('/example')export class HelloController &#123; @Inject() private helloRpc: Hello; @Get('/hello') public async indexAction(@Res() res: Express.Response) &#123; let result = await this.helloRpc.say(&#123;&#125;); res.json(result); &#125;&#125; 开启服务, index.ts1234567891011121314import &#123; ApplicationLoader, ApplicationSettings, Inject, ConfigContainer &#125; from 'mvc-ts';import 'HelloController.ts';import 'Hello.ts';@ApplicationSettings(&#123; rootDir: `$&#123;__dirname&#125;/../` &#125;)class Application extends ApplicationLoader &#123; &#125;const Application = new CpApplication();Application.start(5566);@Settings(settings)class ClientRpc extends RpcClientRegistry &#123; &#125;ClientRpc.start(); settings 参数1234567&#123; port: "3333", // server side grpc port host: "localhost", // server side grpc host ca: "runtime/rpc/ca.crt", // ca file path client_cert: "runtime/rpc/server.crt", // client_cert file path client_key: "runtime/rpc/server.key" // client_key file path&#125; 运行代码1ts-node index.ts ts-node 我是用的 4.x 的版本 打开浏览器访问 http://localhost:5566/example/hello 获得结果123&#123; "word": "hello world"&#125;]]></content>
      <tags>
        <tag>typescript</tag>
        <tag>grpc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用scss方法构建像素化形象]]></title>
    <url>%2F2017%2F06%2F10%2F%E5%88%A9%E7%94%A8scss%E6%96%B9%E6%B3%95%E6%9E%84%E5%BB%BA%E5%83%8F%E7%B4%A0%E5%8C%96%E5%BD%A2%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[像素是一个一个色块组成的，像素化顾名思义就是将图像分成一定的区域，并将这些区域转换成相应的色块，再有色块构成图形。类似于色彩构图。简单说就是将图像转换成像素点组成的点阵图形，也叫栅格化。 准备绘制像素化图像，我们先要将形象进行像素化，将像素化后的点阵图像描述出来，就是颜色矩阵 为此，我们先分析图像上的颜色，共有四种颜色 #fefe00(黄), #823e00(褐), #c69(红), #000(黑) 我们将图像的颜色用矩阵描述出来12345678910111213141516171819202122232425262728// scss代码// 颜色命名$colors: ( y: #fefe00, h: #823e00, r: #c69, k: #000);// 图像矩阵$pixel-art:( $pikachu:( (o o o o o o o o o o o o o o o) (o o o o k k o o o o o o o o o) (k k k k k k k k k o o o o o o) (k k k k k k k y y k k k o o o) (o k y y y k y y y y y y k o o) (o o k y y k k y y y y y y k o) (o o o k y y k y y y y y y k o) (o k k k y k y y y y y k y y k) (o k y y y k y y y r y y y y k) (o o k h k h h h y y y y y k o) (o k h h k y y y y y y k y k o) (o o k h k h h h y y k k y k o) (o o o k k k y y y y y y y k o) (o o o o o o k k y y y k k o o) (o o o o o o o o k k k o o o o) )) 以上就是我们的皮卡丘的颜色矩阵了，现在只要将矩阵上的每一个点像素化就可以了 像素化box-shadow 可以为一个元素添加多个阴影块，我们把每个像素当作一块阴影进行填充，用scss中的函数遍历矩阵，将每个颜色点像素化1234567891011121314151617181920212223242526272829303132333435363738// scss 代码 // 定义每个像素的大小，宽高等值$pixel-size: 4px !default;// 像素化函数@function pixelize($matrix, $size) &#123; $l: length($matrix); // 矩阵长度 $sh: ''; // 阴影值 @for $row from 1 through $l &#123; // 遍历每一行 $row-num: nth($matrix,$row); // 获取每一行有多少点 @for $col from 1 through length($row-num) &#123; // 遍历每一行的节点 $dot: nth($row-num, $col); // 点的位置 $sh: $sh+ ($col*$size)+' '+($row*$size)+' '+map-get($colors,$dot); // 填充该点的阴影值 @if not ($col == length($row-num) and $row==$l)&#123; $sh:$sh+','; &#125; &#125; &#125; @return unquote($sh);&#125;@mixin style-item($matrix,$size)&#123; width: $size*length(nth($matrix,1)); // 容器的宽，与像素化图形等宽 height: $size*length($matrix); // 容器的高，与像素化图形等高 &amp;:after &#123; content: ''; position: absolute; top:-$size; left: -$size; width: $size; height: $size; box-shadow: pixelize($matrix, $size); // 填充阴影 &#125;&#125;// 遍历我们的每一个像素化图形，将每个图形的阴影放到对应的 class 上@each $key,$value in $pixel-art &#123; .#&#123;$key&#125;&#123; @include style-item($value,$pixel-size); &#125;&#125; 结束接下来我们要做的就是，编译这些 scss 代码到 css 文件，可以用 gulp,babel 等工具, 最后，我们在 html 中引入这个 css 文件，并绑定对应的图形 class12345678&lt;html&gt; &lt;head&gt; &lt;link href='path/to/your.css' rel='stylesheet' /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class='pikachu'&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 一只像素化的皮卡丘就跑到我们页面上了]]></content>
      <tags>
        <tag>css</tag>
        <tag>css3</tag>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 公司内测方案]]></title>
    <url>%2F2017%2F05%2F20%2FiOS-%E5%85%AC%E5%8F%B8%E5%86%85%E6%B5%8B%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[App 的搭建正在如火如荼的进行中，每天都有新的 build 版本产生，为了方便跟进开发内容以及收集建议，有 iPhone 设备的同事可以进行版本内测，我会将新的 build 版本进行群共享，这里需要提供自己的一些信息。 UDIDios 的 release 版本部署除了开发者可以任意部署外，要部署到其他人的手机上，需要进行设备的 udid 登记。 获取 iPhone 的 udid 可以通过 iTunes 拿到。具体如图。]]></content>
  </entry>
  <entry>
    <title><![CDATA[从数组M中抽取小数组N，求N的组合情况]]></title>
    <url>%2F2017%2F04%2F06%2F%E4%BB%8E%E6%95%B0%E7%BB%84M%E4%B8%AD%E6%8A%BD%E5%8F%96%E5%B0%8F%E6%95%B0%E7%BB%84N%EF%BC%8C%E6%B1%82N%E7%9A%84%E7%BB%84%E5%90%88%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[算法题：从数组M中抽取小数组N，求N的组合情况，N的内容用下标表示。比如M：[0,1,2,3]，取N的长度为3，结果的N集合为：[0,1,2],[0,1,3],[0,2,3],[1,2,3]。只考虑组合，不考虑排序，例如 [0,1,2], [0,2,1] 只算一个。 确定关系M, N 是不确定的两个数组，N 是 M 满足情况的子集，M.length = m, N.length = n, n &lt; m. 以 m=10, n=4为例。1const m = 10, n = 4; 创建数组 M1const M = Array.from(&#123;length: m&#125;).map((it,i)=&gt;&#123;return i;&#125;); 求取数组 N 的可能性我们通过确定每一位的情况，逐位向后填充，直至取到满足 N 的数组. 先确定第一位的情况。12345678let N = [];for(let i = 0; i &lt; m - n + 1; i++)&#123; /** * N 的每种情况都按顺序填充 * 当 m = 10，n = 4，N[0] 的取值范围应该是 [0~6] 即 m - n */ N[0] = i;&#125; 通过迭代向后填充确定了第一位的情况后，我们可以以此类推，通过迭代，将下一位的每种情况进行填充 将方法封装1234567891011const N_1 = N - 1;function getNextIndex(preN = [], index = 0, MIndex = 0)&#123; for(let i = 0; i &lt; m - MIndex - n + index + 1; i++)&#123; let N = []; // 创建新的数组备份，将上一次求到 N 的内容进行拷贝 for(let t = 0; t &lt; index; t++)&#123; N[t] = preN[t]; &#125; N[index] = M[MIndex + i]; index &lt; N_1 ? getNextIndex(N, index + 1, i + MIndex +1) : null; &#125;&#125; 这样就求出了所有按顺序排列的 N 的可能组合。 综合1234567891011121314151617const m = 10, n = 4;const M = Array.from(&#123;length: m&#125;).map(function(it, i)=&gt;&#123;return i;&#125;);function arrayFilter()&#123; let N_RESULTS = [], RESULTS_MARK = 0; const N_1 = n - 1; getNextIndex(); function getNextIndex(preN = [], index = 0, MIndex = 0)&#123; for(let i = 0; i &lt; m - MIndex - n + index + 1; i++)&#123; let N = []; // 创建新的数组备份，将上一次求到 N 的内容进行拷贝 for(let t = 0; t &lt; index; t++)&#123; N[t] = preN[t]; &#125; N[index] = M[MIndex + i]; index &lt; N_1 ? getNextIndex(N, index + 1, i + MIndex +1) : (N_RESULTS[RESULTS_MARK++] = N); &#125; &#125;&#125; Notes这是整理过后的代码，去掉了很多数组操作，相比旧的代码，性能提升明显 旧的算法1234567891011121314const m = 10, n = 4;const M = Array.from(&#123;length: m&#125;).map(function(it, i)=&gt;&#123;return i;&#125;);function oldarrayFilter() &#123; let N_RESULTS = []; getNextIndex(); function getNextIndex(preN = [], index = 0, arrayIndex = 0) &#123; let N = Array.from(preN); let nextArray = M.slice(arrayIndex); for (let i = 0; i &lt; nextArray.length - n + index + 1; i++) &#123; N[index] = nextArray[i]; (N.length &lt; n) ? getNextIndex(N, index + 1, nextArray[i] + 1): N_RESULTS.push(N); &#125; &#125;&#125; 通过 benchmark 这个库来检测新旧算法的效率1234&gt; node arrayFilter.jsnew x 48,368 ops/sec ±1.41% (82 runs sampled)old x 1,322 ops/sec ±1.83% (77 runs sampled)Fastest is new 主要差异是旧的算法用了较多的数组操作，虽然理解上更方便，写法更直接，却造成了较多的性能开销.]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建局域网服务器shdowsocks隧道实现局域网代理]]></title>
    <url>%2F2017%2F02%2F16%2F%E6%90%AD%E5%BB%BA%E5%B1%80%E5%9F%9F%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8shdowsocks%E9%9A%A7%E9%81%93%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[技术公司经常需要通过科学上网去查询英文资料或高速上网，在公司每人配置一个账号又显得浪费。通过搭建局域网服务器，在局域网服务器上搭建 shadowsocks 隧道代理，让每台电脑通过这台局域网服务器上网，就可以只用一个账号实现公司员工集体翻墙搞事情。 条件 一个能用的 shadowsocks 服务账号 一台内网服务器，我们采用的是 centOS 7 安装 shadowsocks 服务pip是 python 的包管理工具。在本文中将使用 python 版本的 shadowsocks，此版本的 shadowsocks 已发布到 pip 上，因此我们需要通过 pip 命令来安装。 安装 pip在控制台执行以下命令安装 pip：12curl "https://bootstrap.pypa.io/get-pip.py" -o "get-pip.py"python get-pip.py 安装配置 shadowsocks在控制台执行以下命令安装 shadowsocks：12pip install --upgrade pippip install shadowsocks 安装完成后，需要创建配置文件/etc/shadowsocks.json，内容如下：1234567891011&#123; &quot;server&quot;:&quot;1.1.1.1&quot;, #ss服务器IP &quot;server_port&quot;:1035, #ss服务器端口 &quot;local_address&quot;: &quot;127.0.0.1&quot;, #本地ip &quot;local_port&quot;:1080, #本地端口 &quot;password&quot;:&quot;password&quot;, #连接ss密码 &quot;timeout&quot;:300, #等待超时 &quot;method&quot;:&quot;aes-256-cfb&quot;, #加密方式,可选aes-128-cfb, aes-192-cfb, aes-256-cfb, bf-cfb, cast5-cfb, des-cfb, rc4-md5, chacha20, salsa20, rc4, table &quot;fast_open&quot;: false, # true 或 false。如果你的服务器 Linux 内核在3.7+，可以开启 fast_open 以降低延迟。开启方法： echo 3 &gt; /proc/sys/net/ipv4/tcp_fastopen 开启之后，将 fast_open 的配置设置为 true 即可 &quot;workers&quot;: 1 # 工作线程数&#125; 配置自启动新建启动脚本文件/etc/systemd/system/shadowsocks.service，内容如下：1234567[Unit]Description=Shadowsocks[Service]TimeoutStartSec=0ExecStart=/usr/bin/sslocal -c /etc/shadowsocks.json[Install]WantedBy=multi-user.target 执行以下命令启动 shadowsocks 服务：12systemctl enable shadowsockssystemctl start shadowsocks 检查 shadowsocks 服务是否已成功启动1systemctl status shadowsocks -l Convert Shadowsocks into an HTTP proxy我们要将 socks 服务转为 http 实现 http(s) 代理 安装 polipo执行以下命令安装 polipo 服务：12345wget https://www.irif.fr/~jch/software/files/polipo/polipo-1.1.1.tar.gztar -xf polipo-1.1.1.tar.gzcd polipo-1.1.1make allmake install 配置 polipo 服务创建配置文件夹1mkdir /etc/polipo 从源码目录拷贝配置文件：1cp config.sample /etc/polipo/config 可根据需要配置选项 后台启动服务1nohup polipo socksParentProxy=localhost:1080 &amp; 测试代理测试挂载的代理是否可以使用12export https_proxy=http://127.0.0.1:8123curl https://www.facebook.com 若能拉取页面资源，则代理成功 局域网使用局域网内的电脑通过设置网络代理我的内网服务器内网 ip 是 192.168.1.18 win 10 直接在设置中带开网络设置，添加手动代理， 地址 192.168.1.18 端口 8123打开浏览器使用谷歌搜索马上翻墙搞事情]]></content>
      <tags>
        <tag>net</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3 动画性能优化(1)]]></title>
    <url>%2F2017%2F01%2F23%2Fcss3-%E5%8A%A8%E7%94%BB%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-1%2F</url>
    <content type="text"><![CDATA[在传统网页上动画一般都是通过 Javascript 或 flash 来实现，但是 html5 的时代的到来，CSS 的进化，让动画实现起来更加 easy。 现代的浏览器通常会有两个重要的执行线程，这2个线程协同工作来渲染一个网页 主线程 合成线程 一般情况下，主线程负责： 运行 JavaScript。 计算 HTML 元素的 CSS 样式。 页面的布局 将元素绘制到一个或多个位图中 将这些位图交给合成线程 相应地，合成线程负责： 通过 GPU 将位图绘制到屏幕上 通知主线程更新页面中可见或即将变成可见的部分的位图 计算出页面中哪部分是可见的 计算出当你在滚动页面时哪部分是即将变成可见的 当你滚动页面时将相应位置的元素移动到可视区域 Example width 过渡我们绘制一个新闻卡片，让其在鼠标移上时产生动画，为了节省时间，css 采用 sass/scss 编译 html 代码：123456789101112&lt;div class="box"&gt; &lt;div class="img-box"&gt; &lt;img src="./images/baobao.jpeg" /&gt; &lt;/div&gt; &lt;div class="content"&gt; &lt;p&gt;hello world&lt;/p&gt; &lt;p&gt;hello world&lt;/p&gt; &lt;p&gt;hello world&lt;/p&gt; &lt;p&gt;hello world&lt;/p&gt; &lt;p&gt;hello world&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; scss 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859.box &#123; width: 120px; box-shadow: 0 0 10px 0 #777; @include comic(.3); &amp;:hover &#123; -webkit-animation: box 1s forwards; .content &#123; -webkit-animation: content 1s forwards; -webkit-animation-delay: .5s; p &#123; -webkit-animation: p 1s forwards; -webkit-animation-delay: .5s; &#125; &#125; &#125; border-radius: 50%; overflow: hidden; .img-box &#123; width: 100%; img &#123; width: 100%; &#125; &#125; .content &#123; padding: 0; p &#123; height: 0; margin: 0; line-height: 20px; &#125; &#125;&#125;@keyframes box &#123; 0% &#123;&#125; 100% &#123; width: 200px; border-radius: 0; &#125;&#125;@keyframes content &#123; 0% &#123;&#125; 100% &#123; padding: 10px; &#125;&#125;@keyframes p &#123; 0% &#123;&#125; 100% &#123; height: 20px; margin: 1em 0; &#125;&#125;@mixin comic($time) &#123; -webkit-transition: #&#123;$time&#125;s ease-in-out; -moz-transition: #&#123;$time&#125;s ease-in-out; -ms-transition: #&#123;$time&#125;s ease-in-out; -o-transition: #&#123;$time&#125;s ease-in-out; transition: #&#123;$time&#125;s ease-in-out;&#125; 鼠标悬停时，会产生如下效果 打开 chrome 浏览器的 timeline 观看整个动画绘制情况 从 range 可以看出 redering 和 painting 所花费的时间情况，整个动画稳定在 55-60 fps 左右。这是在配置较好的笔记本上的情况，尝试在较为旧款的设备上查看，有时会降为 40 fps 左右，略有卡顿。 容器宽度（width）动画流程大致如下： 左线程为主线程，右线程为合成线程 如图所示，浏览器在进行一次 css 动画的时候，需要将动画进行切片，每进行一次帧过渡，都需要主线程与合成线程进行协调。在动画的每一帧中，浏览器都要执行布局、 绘制、 以及将新的位图提交给 GPU。我们知道，将位图加载到 GPU 的内存中是一个相对较慢的操作。 浏览器需要做大量工作的原因在于每一帧中元素的内容都在不断改变。改变一个元素的高度可能导致需要同步改变它的子元素的大小，所以浏览器必须重新计算布局。布局完成后，主线程又必须重新生成该元素的位图。浏览器需要做大量的工作，也就是说这个动画可能会变得卡顿。 scale 过渡将 width 的数值过渡改成缩放过渡1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253.box &#123; width: 200px; box-shadow: 0 0 10px 0 #777; @include comic(.3); -webkit-transform: scale(.6); &amp;:hover &#123; -webkit-animation: box 1s forwards; .content &#123; -webkit-animation: content 1s forwards; -webkit-animation-delay: .5s; p &#123; -webkit-animation: p 1s forwards; -webkit-animation-delay: .5s; &#125; &#125; &#125; border-radius: 50%; overflow: hidden; .img-box &#123; width: 100%; img &#123; width: 100%; &#125; &#125; .content &#123; padding: 0; p &#123; height: 0; margin: 0; line-height: 20px; &#125; &#125;&#125;@keyframes box &#123; 0% &#123;&#125; 100% &#123; -webkit-transform: scale(1); border-radius: 0; &#125;&#125;@keyframes content &#123; 0% &#123;&#125; 100% &#123; padding: 10px; &#125;&#125;@keyframes p &#123; 0% &#123;&#125; 100% &#123; height: 20px; margin: 1em 0; &#125;&#125; 同样打开 chrome 浏览器的 timeline 观看整个动画绘制情况 会发现 rendering 和 painting 的时间都缩短了。 同时在时间轴上可以看到最大可以达到 90 几 fps（有时可以达到100以上） 容器宽度（width）动画流程大致如下： 我们可以看到少了很多主线成与合成线程之间的交换，意味着动画变得更流畅了。 原因根据定义，CSS 的transform属性不会更改元素或它周围的元素的布局。transform属性会对元素的整体产生影响，它会对整个元素进行缩放、旋转、移动处理。 而改变 width, height, maigin 等属性的时候，会造成元素布局的重排而触发重绘，影响 gpu 的线性计算。 这只是一个相对简单的动画实例，对比情况并不明显，在涉及内连元素较多的动画同时进行时，对比会更为突出。 最后进行用以下属性来做 css 动画 CSS transform CSS opacity CSS filter（取决于filter的复杂度以及浏览器的实现）避免使用 height,width,margin,padding 等；]]></content>
      <tags>
        <tag>css</tag>
        <tag>css3</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 border-radius]]></title>
    <url>%2F2017%2F01%2F18%2FCSS3-border-radius%2F</url>
    <content type="text"><![CDATA[早些年CSS3 border-radius 的文档或者文章，会发现，根本就没有提过百分比值这一茬。究其原因，是因为百分比值的支持是后来才支持的，跟数值不是一起出来的。比方说某些老版本的 Android 机子，border-radius:50% 它就不认识。 早期浏览器支持 border-radius 都是浏览器标准实现，并不形成统一标准。兼容旧版本浏览器需要用到浏览器内核前缀 -webkit-border-radius, -moz-border-radius。浏览器个把年前就把私有前缀给去掉了，现在完全没必要使用。 作用border-radius 是向块级元素添加圆角边框。 原理既然是添加圆角边框，那么圆角边框是怎么被确定出来的，为什么这么多。 首先确定圆角边框其实就是一个弧边。一个标准的圆角弧边是由圆裁切出来的。圆的半径决定了圆的大小，也就决定了弧边裁剪出来的弧长和弧度。 border-radius 绝对数值border-radius 的值是绝对像素数值 apx(px是单位像素) 的时候，切出来的弧边正好是一个以 apx 为半径的圆的 1/4 圆角弧边。 例如，一个宽高为 200px 的正方形 div， 设置 50px 的 border-radius，圆角边框就是 50px 为半径的圆的 1/4 圆角弧边1234567891011121314&lt;style&gt;.square&#123; width: 200px; height:200px; border: 1px solid #000; margin-right: 100px; display:inline-block&#125;.radius&#123; border-radius: 50px;&#125;&lt;/style&gt;&lt;div class='square'&gt;&lt;/div&gt;&lt;div class='square radius'&gt;&lt;/div&gt; 当 apx 为正方形 div 边长的一半时，div 正好是一个正圆123.radius&#123; border-radius: 100px;&#125; apx 的最大值是元素边长的一半, 当 apx 超过一半时，将自动取边长的一半123.radius&#123; border-radius: 150px;&#125; 如果 div 是一个长方形，那么 border-radius 的取值最大是最短边的一半1234567891011121314&lt;style&gt;.square&#123; width: 400px; height:200px; border: 1px solid #000; margin-right: 100px; display:inline-block&#125;.radius&#123; border-radius: 150px;&#125;&lt;/style&gt;&lt;div class='square'&gt;&lt;/div&gt;&lt;div class='square radius'&gt;&lt;/div&gt; 1234567.square&#123; width: 200px; height:400px; border: 1px solid #000; margin-right: 100px; display:inline-block&#125; border-radius 百分比值现代浏览器为 border-radius 加入了半分比值的支持。半分比值生成的圆角边框，是从元素顶点处，往两个邻边取出边长的一半的半分比长度所确定的椭圆的 1/4 弧边首先我们了解，标准椭圆的确定概念 椭圆（Ellipse）是平面内到定点F1、F2的距离之和等于常数（大于|F1F2|）的动点P的轨迹，F1、F2称为椭圆的两个焦点。其数学表达式为：|PF1|+|PF2|=2a（2a&gt;|F1F2|）。 1234567891011121314&lt;style&gt;.square&#123; width: 200px; height:200px; border: 1px solid #000; margin-right: 100px; display:inline-block&#125;.radius&#123; border-radius: 20%;&#125;&lt;/style&gt;&lt;div class='square'&gt;&lt;/div&gt;&lt;div class='square radius'&gt;&lt;/div&gt; F1, F2 的位置是浏览器给出，因此很难说其切面弧角的大小。 百分比值最大取到 50%，即为各边一半，超过 50% 按照 50%计算。123.radius&#123; border-radius: 50%;&#125; 123.radius&#123; border-radius: 80%;&#125; 多个参数border-radius 支持传入多个参数进行设置圆角边框，只有一个参数时表示4个角的圆角是一样的，多个参数时即为每个角单独设置，顺序是：左上，右上，右下，左下1234567891011121314&lt;style&gt;.square&#123; width: 200px; height:200px; border: 1px solid #000; margin-right: 100px; display:inline-block&#125;.radius&#123; border-radius: 10px 20px 20px 20%;&#125;&lt;/style&gt;&lt;div class='square'&gt;&lt;/div&gt;&lt;div class='square radius'&gt;&lt;/div&gt; ;]]></content>
      <tags>
        <tag>css</tag>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[约瑟夫环的思考]]></title>
    <url>%2F2017%2F01%2F11%2F%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[基本思路首先创建一个 1～100 的数组。12345678910[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100] 每隔 7 取一个数，剔除，第一次被剔除的数就是1[7,14,21,28,35,42,49,56,63,70,77,84,91,98] 剩下的数排列成新的数组12345678910[1,2,3,4,5,6,8,9,10,11,12,13,15,16,17,18,19,20,22,23,24,25,26,27,29,30,31,32,33,34,36,37,38,39,40,41,43,44,45,46,47,48,50,51,52,53,54,55,57,58,59,60,61,62,64,65,66,67,68,69,71,72,73,74,75,76,78,79,80,81,82,83,85,86,87,88,89,90,92,93,94,95,96,97,99,100] 剔除掉的最后一个数 98，往后还剩 99，100 两个数，在新的数组里，要排到头里继续算，因此新数组每个元素的游标都被前置了 2（因为第一次循环还剩2个数没算）,所以在新数组里从第一个元素开始计算时，每个元素的游标都加 2， 第二次被剔除的数就是1[20,26,39,50,64,82,85] 此时剔除掉最后一个数时，还剩 85 未被计算，游标前置了 1，继续循环123456[20,26,39,50,64,85] ~1[20,26,39,50,64] ~0[20,39,50,64] ~3[20,39,50] ~0[39,50] ~2[50] 往后继续排除到只剩一个数 [50] 程序设计定义一个 100 的数组1var array = Array.from(&#123;length:100&#125;).map((item,i)=&gt;&#123;return i+1;&#125;); 每隔 7 个数剔除，其实就是将游标(i)能整除 7 的元素剔除，因为数组的起始游标是 0，所以实际计算时，游标应该是(i+1),定义每次的起始基点为 left,每次循环计算后都剩余几个数未计算，剩余的元素个数作为新的基点，所以计算后的实际游标就是(i+1+left),初始化基点 left 为 0,步长 step 为 71var left = 0, step = 7; 每次遍历后剔除掉满足游标的元素后，生成新的数组，算上基点重新遍历迭代，直到只剩 1 个元素123456789101112131415161718var array = Array.from(&#123;length:100&#125;).map((item,i)=&gt;&#123;return i+1;&#125;);var left = 0, step = 7;function goal(left, s, arr)&#123; console.log(arr); // 打印每次的起始数组 let length = arr.length // 数组长度 if(length == 1) return console.log(arr); // 当只剩 1 个元素时，停止计算 let ar = arr.filter((item, i)=&gt;&#123; return (i+1+left)%s != 0; // 取出满足游标的元素 &#125;); let dar = arr.filter((item, i)=&gt;&#123; return (i+1+left)%s == 0; // 取出满足游标与步长取模为 0 的元素 &#125;); left += length-s*(length-ar.length); // 得到新的基点 console.log(dar); // 打印被剔除掉的元素 console.log(left); // 打印新的基点 goal(left, s, ar); // 将新的基点和新的数组迭代计算&#125;goal(left, step, array);]]></content>
      <tags>
        <tag>idea</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动实现简单模版数据绑定]]></title>
    <url>%2F2016%2F12%2F29%2F%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%A8%A1%E7%89%88%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[MVVM是Model-View-ViewModel的简写, 主要目的是分离视图（View）和模型（Model）。 mvvm 框架是时下热点的前端讨论话题，通过分离 视图 和 模型，简化开发流程，提高开发效率。 mvvm 的模版引擎，通过数据双向绑定，实现 View-Model, Model-View 之间的数据更新。 本节先介绍如何先实现简单模版引擎以及数据绑定。 定义模版1234&lt;div id='demo'&gt; &lt;p&gt;hello &#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;p&gt;this page is init on &lt;span class=&#123;&#123;color&#125;&#125;&gt;&#123;&#123;date&#125;&#125; !!!!!!&lt;/span&gt;&lt;/p&gt;&lt;/div&gt; 我们通过 来定义模版中需要替换的变量。 定义模版驱动123function MVVM(ele)&#123; this.dom = document.querySelector(ele);&#125; 遍历模版定义方法，遍历模版中的属性，以及子节点及其属性，提取出需要替换的变量12345678910111213141516171819202122232425262728293031323334353637383940414243444546MVVM.prototype = &#123; /** * 遍历传入的节点或属性集合 */ each(dom, cb)&#123; Array.prototype.forEach.call(dom, function(item, index)&#123; cb.call(item, index, item); &#125;); &#125;, /** * 开启模版替换 */ renderDom(dom)&#123; var self = this; self.each(dom.attributes, function()&#123; self.render(this); &#125;); self.each(dom.childNodes, function() &#123; if (this.nodeType == 1) return self.renderDom(this); self.render(this); &#125;); &#125;, /** * 替换 节点 */ render(node) &#123; var self = this; var result = node.textContent; var keys = node.textContent.match(/\&#123;\&#123;\w+\&#125;\&#125;/g); if (!keys) return; var model = self.model; keys.map(item =&gt; &#123; return item.replace(/(\&#123;\&#123;|\&#125;\&#125;)/g, ''); &#125;).forEach(key =&gt; &#123; result = result.replace(`&#123;&#123;$&#123;key&#125;&#125;&#125;`, model[key] || ''); &#125;); node.textContent = result; &#125;, /** * 执行入口 */ init()&#123; var self = this; self.renderDom(self.dom); &#125;&#125; 整合通过 MVVM 对象，我们可以渲染出最初定义的 demo，代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;mvvm test&lt;/title&gt; &lt;style type="text/css"&gt; .blue &#123; color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='mvvm'&gt; &lt;p&gt;hello &#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;p&gt;this page init on &lt;span class="&#123;&#123;color&#125;&#125;"&gt;&#123;&#123;date&#125;&#125; !!!!!&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; function MVVM(ele) &#123; this.dom = document.querySelector(ele); &#125; MVVM.prototype = &#123; init() &#123; var self = this; self.renderDom(self.dom); &#125;, renderDom(dom) &#123; var self = this; self.each(dom.attributes, function() &#123; self.render(this); &#125;); self.each(dom.childNodes, function() &#123; if (this.nodeType == 1) return self.renderDom(this); self.render(this); &#125;); &#125;, each(dom, cb) &#123; Array.prototype.forEach.call(dom, function(item, index) &#123; cb.call(item, index, item); &#125;); &#125;, render(node) &#123; var self = this; var result = node.textContent; var keys = node.textContent.match(/\&#123;\&#123;\w+\&#125;\&#125;/g); if (!keys) return; var model = self.model; keys.map(item =&gt; &#123; return item.replace(/(\&#123;\&#123;|\&#125;\&#125;)/g, ''); &#125;).forEach(key =&gt; &#123; result = result.replace(`&#123;&#123;$&#123;key&#125;&#125;&#125;`, model[key] || ''); &#125;); node.textContent = result; &#125; &#125; var mvvm = new MVVM('#demo'); mvvm.model = &#123; name: 'world', date: new Date(), color: 'blue' &#125;; mvvm.init(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果替换前替换后]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>mvvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript(2) 数据类型(2)]]></title>
    <url>%2F2016%2F12%2F22%2Fjavascript-2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-2%2F</url>
    <content type="text"><![CDATA[ObjectObject 类型是一种引用数据类型。它指向内存中被标识引用的一个区块。为一个变量赋予一个引用类型数据，变量将指向改引用数据的原始值，而不创建副本。 不同于字符串的值类型。字符串在赋值时，会创建副本，具体情况：12345var a = 'hello';var b = a;b += ' world';console.log(a); // helloconsole.log(b); // hello world 值类型数据为 b 创建了副本，b 的值改变创建了一个新的字符串，不改变 a 的原始值 区别于Object12345var a = &#123; a: 'hello' &#125;;var b = a;b.b = 'world';console.log(a); // &#123; a: 'hello', b: 'world' &#125;console.log(b); // &#123; a: 'hello', b: 'world' &#125; 引用类型数据， var b = a 是将 a 的引用传给 b， a, b 指向同一个内存引用区块，改变 b 的数据实际上是改变内存中指向的区块所存储的内容，因此 a 引用到的数据也跟着改变。 引用数据比较1234var a = &#123; a: 'hello world' &#125;;var b = a;a == b; // truea === b; // true 因为 b 是使用了 a 的引用，a，b 指向内存的同一区块，所以 a 跟 b 是等价的。但是1234var a = &#123; a: 'hello world' &#125;;var b = &#123; a: 'hello world' &#125;;a == b; // falsea === b; // false 创建了一个新的 Object 数据给 b，虽然 a，b 的字面量是一样的，但是 a 与 b 具有不同的引用，对于引用数据的比较，实际是是比较它们的引用。 引用数据变量实际上只保存了引用的内存指针，使用时，是从指针中往内存检索数据。即使字面量一样，但是引用不同，变量就不是等价的。 property对象被看作是一组属性的集合，ECMAScript定义的对象中有两种属性：数据属性和访问器属性。 数据属性是键值对，并且每个数据属性拥有下列特性: [Value]] [[Writable]] [[Enumerable]] [[Configurable]] 一个 Object 对象是一组键值对的集合，键和值之间的映射关系，键是一个字符串，值可以是任意数据类型。 function 是一个附带可被调用功能的特殊对象 javascript中，很多原型对象数据类型，都是基于 Object 的派生，如：Date, Array, Map, WeakMap 等。 Array数组是通过整数标识键，并与长度进行内联的常规对象。键作为数组的游标，与字符串的索引类似。 通过了解数组的构成，可以模拟出数组的数据结构。 *注意，arguments 在 javascript 中，函数的传参被保存在 arguments 对象中，arguments 是一个类数组对象，并非是数组。它和数组一样，具有整数有序游标，和长度关系。12345function x()&#123; console.log(arguments); // 执行到这里会输出 Arguments[1, 2] arguments.push(3); // Uncaught TypeError: arguments.push is not a function&#125;x(1, 2); 展开 Arguments[1, 2]，可以看到它的数据结构是一个整数游标键，并具有 length。与数组结构相似。但并不是一个数组，所以不具备数组的方法。 javascript 可以通过 call 和 apply 方法继承。12345function x()&#123; Array.prototype.push.call(arguments, 3) console.log(arguments); // 执行到这里会输出 Arguments[1, 2, 3]&#125;x(1, 2); 构建一个类数组对象 1234var a = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3 &#125;;Array.prototype.forEach.call(a, function(value, index)&#123; console.log(value,',',index); // 会依次输出 a, 0 b, 1 c, 2&#125;);]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript(1) 数据类型(1)]]></title>
    <url>%2F2016%2F12%2F22%2Fjavascript-1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-1%2F</url>
    <content type="text"><![CDATA[ECMAScript 定义了7种标准的数据类型 6种基本数据类型 Boolean Null Undefined Number String Symbol (es6 标准新增) 1种特殊数据类型 Object 原始值除了 Object 以外的数据类型，值本身是不可变的。例如：对字符串进行操作，返回了一个新字符串，而原始字符串本身并没有被改变。 所以除 Object 类型变量外，要改变变量的值，需要重新赋值。12345var str = 'hello';str + ' world'; // 表达式返回 'hello world'console.log(str); // 输出 'hello', str 本身的值没有被改变str += ' world'; // 表达式返回 'hello world'console.log(str); // 输出 'hello world', str 被重新赋值 BooleanBoolean 表示一个逻辑实体，有两个值：true, false。 所有的值都可以解释成布尔值，除了一些特定值被解释成 false，其他值都将解释成 true。 false : false, undefined, null, 0, ‘’(空字符串), NaN注意：这些值虽然可以解释成 false，但并不表示就与 false 等价：12345678910undefined == false; // falseundefined === false; // falsenull == false; // falsenull === false; // false0 == false; // true0 === false; // false'' == false; // true'' === false; // falseNaN == false; // falseNaN === false; // false Nullnull 是 javascript 的一个字面量，表示空。 null 常用做表示期望对象，但是没有任何引用。 Undefined通常所说的 undefined 是指全局对象的一个属性 window.undefined。 未初始化的变量都有一个默认值 undefined，未被传入实参的形参值为 undefined，未添加 return 返回值的函数，默认返回 undefined。123456var x; // undefinedfunction x1(a)&#123; console.log(a); // without return&#125;x1(); // return undefined, and console print a as undefined. null 与 undefined 比较1234typeof null; // object, 空引用对象，有些人觉得这应该算是一个 bugtypeof undefined; // undefinednull == undefined; // truenull === undefined; // false 判断一个值是否是 undefined：12345var x;x === undefined &amp;&amp; 1 || 0; // 1typeof x === 'undefined' &amp;&amp; 1 || 0; // 1typeof y === 'undefined' &amp;&amp; 1 || 0; // 1y === undefined &amp;&amp;1 || 0; // ReferenceError, y 未被声明过 Number数值类型的取值范围 -(2^53 -1) 到 2^53 -1 (SAFE_INTEGER_VALUE)。javascript 数值类型没有类似 java 分为整型，长整型，浮点型，双精度浮点型。 javascript 中所有数值都是 Number 类型。除了数值外，Number还包括一些带符号的值：+/-Infinity, NaN(Not-a-Number)。 *注意：0 === -0 为真， 但在计算时：121/0; // Infinity1/-0; // -Infinity String字符串类型用于表示文本数据，它是一个带索引的元素集合，字符串中每个元素都占据一个位置，第一个元素的索引是 0，往后递增。 字符串一旦被创建，就不会被更改，字符串操作会返回一个新的字符串，但不会改变原始字符串。 表达文本数据和符号数据时候推荐使用字符串。当表达复杂的数据时，使用字符串解析和适当的缩写。 *注意：对于数值字符串和数值型数据：12'1' == 1; // true'1' === 1; // false 所以在对一些数据判断时，无法保证传入的是数值型字符串或数值型数据，根据使用场景判断是否使用严格相等操作符。]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用redis订阅实现定时任务(node.js)]]></title>
    <url>%2F2016%2F11%2F29%2F%E4%BD%BF%E7%94%A8redis%E8%AE%A2%E9%98%85%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-node-js%2F</url>
    <content type="text"><![CDATA[条件安装的redis版本至少为2.8.0，查看redis版本1234&gt; redis-cli --versionredis-cli 3.2.5&gt; redis-server --versionRedis server v=3.2.5 sha=00000000:0 malloc=libc bits=64 build=112b103d6428f815 只有2.8.0以上的版本支持键事件订阅 开启键失效事件123456789101112redis事件：K Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.E Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.g Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...$ String commandsl List commandss Set commandsh Hash commandsz Sorted set commandsx Expired events (events generated every time a key expires)e Evicted events (events generated when a key is evicted for maxmemory)A Alias for g$lshzxe, so that the &quot;AKE&quot; string means all the events. redis默认是关闭键事件订阅，可以在bash输入以下命令开启，因为我们只要订阅键失效的事件，所以只需要Ex就够了：12&gt; redis-cli config set notify-keyspace-events ExOK 订阅事件在第一个终端窗口(windows是控制台cmd)，打开redis-cli，进行以下操作123456&gt; redis-cli&gt; PSUBSCRIBE __keyevent@1__:expiredReading messages... (press Ctrl-C to quit)1) "psubscribe"2) "__keyevent@1__:expired"3) (integer) 1 __keyevent代表订阅的是键事件，1是redis的db，expired表示订阅的是键失效的事件 如果要订阅所有数据库的键，可以改成：1&gt; PSUBSCRIBE __keyevent@*__:expired 触发订阅在新的一个终端或控制台中，打开redis-cli，创建一个键，并让其失效：1234567&gt; redis-cli&gt; select 1OK&gt; set mykey 'hello'OK&gt; expire mykey 10(integer) 1 10秒后mykey过期会触发终端1的事件订阅，终端1会输出12341) "pmessage"2) "__keyevent@1__:expired"3) "__keyevent@1__:expired"4) "mykey" 所以我们只要制定好键的过期时间，去触发键订阅事件，利用这个特性，可以实现定时任务 node.js代码用到第三方模块redis(npm install redis)12345678910111213141516'use strict';let redis = require('redis');let child_process = requrie('child_process');const keyClient = redis.createClient(&#123;db: 1&#125;);const pubClient = redis.createClient();child_process.execSync('redis-cli config set notify-keyspace-events Ex'); // 确保键事件订阅开启pubClient.psubscribe('__keyevent@1__:expired');keyClient.set('mykey', 'hello', ()=&gt;&#123; keyClient.pexpireat('mykey', +new Date('2016/12/23 10:00:00'));&#125;);let futureFun = () =&gt;&#123; console.log('hello world');&#125;;pubClient.on('pmessage', (channel, listen, key)=&gt;&#123; key == 'mykey' &amp;&amp; futureFun();&#125;); futureFun会在2016/12/23 10点，mykey这个键过期的时候执行。]]></content>
      <tags>
        <tag>node.js</tag>
        <tag>javascript</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎么看待facebook包管理器 yarn]]></title>
    <url>%2F2016%2F10%2F26%2F%E6%80%8E%E4%B9%88%E7%9C%8B%E5%BE%85facebook%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8-yarn%2F</url>
    <content type="text"><![CDATA[Yarn 是一个Facebook推出的新的包管理器，用于替代现有的 npm 客户端或者其他兼容 npm 仓库的包管理工具。Yarn 保留了现有工作流的特性，优点是更快、更安全、更可靠。 对于npm，最大的缺点就是慢，特别是对于国内的开发者来说，墙外的世界总是爱不释手又遥不可及。一个大点的依赖包可能需要近半个小时才能down下来。还好我们还有cnpm，还有taobao的镜像源。 yarn到底有多快，能不能取代npm安装，下面通过安装几个模块来验证一下。 安装相同的包express所耗费的时间为了不浪费时间做无谓的测试，就不直接测试npm的源了，而是将npm的源更换为我已经搭好的国内镜像服务。 yarn使用默认源，npm使用国内镜像1234567891011121314// 因为npm不能直接输出安装时间，所以我们选择通过代码检测整个程序的穿透时间来做测量'use strict';let child_process = require('child_process');function test(m)&#123; console.time(`$&#123;m&#125; finished in :`); child_process.exec(`$&#123;m == 'npm' &amp;&amp; (m + ' install') || (m + ' add')&#125; express`,function()&#123; console.timeEnd(`$&#123;m&#125; finished in :`); &#125;);&#125;test('npm'); // finished in 4331.464mstest('npm'); // finished in 1809.988ms// 清空掉安装历史，继续执行以下代码test('yarn'); // finished in 2810.565mstest('yarn'); // finished in 1106.524ms 将yarn安装源换成与npm一样的国内镜像1234// 为了测试整个项目的可用性，挑选了一个依赖较多的项目来做干净安装测试yarn install // 43.27snpm install // &gt;100s// 该测试都是在使用同一源的情况下进行 安装在我私有源上的私有包1234567891011121314// 在开发的时候，我们搭建私有npm代理服务的目的也是为了管理只有自己使用的一些内部扩展包，如果不支持私有包的安装，yarn就无法取代传统的npm'use strict';let child_process = require('child_process');function test(m)&#123; console.time(`$&#123;m&#125; finished in :`); child_process.exec(`$&#123;m == 'npm' &amp;&amp; (m + ' install') || (m + ' add')&#125; @ym/rpc`,function()&#123; console.timeEnd(`$&#123;m&#125; finished in :`); &#125;);&#125;test('npm'); // finished in 7547.653mstest('npm'); // finished in 5121.880ms// 清空掉安装历史，继续执行以下代码test('yarn'); // finished in 2752.662mstest('yarn'); // finished in 1140.099ms yarn在即使不使用国内镜像访问的时候，安装公有包的速度依然比使用国内镜像的npm快，在使用同是国内镜像源的时候，优势更是明显。 测试安装整个项目依赖1234// 为了测试整个项目的可用性，挑选了一个依赖较多的项目来做干净安装测试yarn install // 43.27snpm install // &gt;100s// 该测试都是在使用同一源的情况下进行 focus以上安装测试每个都至少测试3次，每次测试都需清空掉安装信息，平均安装时间误差波动不大 综述yarn用作包管理器，在速度上确实有很大优势，也支持私有npm包管理安装。 除了有时候会有不稳定的情况出现，整体上还是很不错的，只要稍加优化，作为npm的替代品是没有问题]]></content>
      <tags>
        <tag>yarn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa-qx-router | XueZier]]></title>
    <url>%2F2016%2F10%2F26%2Fkoa-qx-router-XueZier%2F</url>
    <content type="text"><![CDATA[配合koa@v2使用的路由注册系统,Now , you can use the service !!!! please see the readme.md123456789101112131415161718192021 _oo0oo_ 088888880 88" . "88 (| -_- |) 0\ = /0 ___/'---'\___ .' \\| |// '. / \\||| : |||// \ /_ ||||| -:- |||||- \ | | \\\ - /// | | | \_| ''\---/'' |_/ | \ .-\__ '-' __/-. / ___'. .' /--.--\ '. .'___ ."" '&lt; '.___\_&lt;|&gt;_/___.' &gt;' "". | | : '- \'.;'\ _ /';.'/ - ' : | | \ \ '_. \_ __\ /__ _/ .-' / / ====='-.____'.___ \_____/___.-'____.-'===== '=---='^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Buddha bless : : Never BUGs Installation (via npm)npm install koa-qx-router or npm install koa-qx-router –save UsageOn Main Server1234const qx = require("koa-qx-router");const qxServer = new qx.server();qxServer.listen(mainPort, mainHostname, cb); Install AuthInstall auth must be used. add an auth at least. An auth can only be used by one person to cerate client Service to connect the main service.1qxServer.install(&#123;name1:pass1, name2:pass2 ...&#125;); On Client Servercreate a app12const koa = require("koa");const app = new koa(); create a client service object123456789const qx = require("koa-qx-router");const qxClient = new qx.client(&#123; port: mainPort, // 主路由的端口,default 1333 hostname: mainHostname, // 主路由的hostname,default 127.0.0.1 auth:&#123; name: auth_name, // 注册主路由时的auth,作为验证,需要在主路由中先配置此项 pass: auth_pass &#125;&#125;); Origin Cors1app.use(qxClient.cors(options)); OptionsConfigures the Access-Control-Allow-Origin CORS header. Options is a json.1234origin Array, default [*], set `Access-Control-Allow-Origin`credentials Boolean, default false, set `Access-Control-Allow-Credentials`allowMethods String, default &apos;GET,HEAD,PUT,POST,DELETE&apos;, set `Access-Control-Allow-Methods`strict Boolean, false, set `Access-Control-Allow-Origin` cors model Auth1234app.use(qxClient.auth(&#123; name: name, pass: pass&#125;)); if didnt set name and pass, qxClient will auto generate a name and pass. BodyParser1app.use(qxClient.bodyParser(options)) OptionsParse the request body. options is a json1234567encoding String, default `utf-8`multipart Boolean, allow multipart data, default true,jsonLimit String|Integer, The byte (if integer) limit of the JSON body, default 1mbformLimit String|Integer, The byte (if integer) limit of the form body, default 56kbtextLimit String|Integer, The byte (if integer) limit of the text body, default 56kbpatchNode Boolean, Patch request body to Node&apos;s ctx.req, default falsepatchKoa Boolean, Patch request body to Koa&apos;s ctx.request, default true add koa-router123456const router = require("koa-router")();router.all("/getname", function* ()&#123; this.body = "ok";&#125;);app.use(router.routes());app.use(router.allowedMethods()); start client service1app.listen(clientPort, qxClient.registerServer(app)); Now, defined a rest Api for http://127.0.0.1:clientPort/getname, access the api you can use curl like1curl http://mainHostname:mainPort/auth_name/getname Supportuse the module must start least 2 service processes. 1 for Main service, others for client service processes. Main service process is open to the outside world. Client service processes is closed, not open to the outside world. Users only through the main service process to access client service processes.]]></content>
      <tags>
        <tag>node.js</tag>
        <tag>javascript</tag>
        <tag>net</tag>
      </tags>
  </entry>
</search>
